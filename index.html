<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Parquet Viewer - DuckDB Powered</title>

    <!-- TailwindCSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
      tailwind.config = {
        darkMode: "class",
        theme: {
          extend: {
            colors: {
              primary: "#3b82f6",
              secondary: "#6366f1",
              accent: "#8b5cf6",
            },
          },
        },
      };
    </script>

    <!-- React -->
    <script
      crossorigin
      src="https://unpkg.com/react@18/umd/react.production.min.js"
    ></script>
    <script
      crossorigin
      src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"
    ></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- ECharts -->
    <script src="https://cdn.jsdelivr.net/npm/echarts@5.4.3/dist/echarts.min.js"></script>

    <style>
      /* Custom scrollbar */
      ::-webkit-scrollbar {
        width: 8px;
        height: 8px;
      }
      ::-webkit-scrollbar-track {
        background: #1f2937;
      }
      ::-webkit-scrollbar-thumb {
        background: #4b5563;
        border-radius: 4px;
      }
      ::-webkit-scrollbar-thumb:hover {
        background: #6b7280;
      }

      /* Loading spinner */
      .spinner {
        border: 3px solid #374151;
        border-top: 3px solid #3b82f6;
        border-radius: 50%;
        width: 24px;
        height: 24px;
        animation: spin 1s linear infinite;
      }
      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      /* Transitions */
      .fade-in {
        animation: fadeIn 0.3s ease-in;
      }
      @keyframes fadeIn {
        from {
          opacity: 0;
        }
        to {
          opacity: 1;
        }
      }
    </style>
  </head>
  <body class="bg-gray-900 text-gray-100 min-h-screen">
    <div id="root"></div>

    <script type="text/babel">
      const { useState, useEffect, useRef, useCallback, useMemo } = React;

      // ===========================================
      // API Client
      // ===========================================
      const API_BASE = "";

      const api = {
        async getFiles() {
          const res = await fetch(`${API_BASE}/api/files`);
          const data = await res.json();
          return data.files || [];
        },

        async getColumns(file) {
          const res = await fetch(
            `${API_BASE}/api/columns?file=${encodeURIComponent(file)}`
          );
          const data = await res.json();
          return data.columns || [];
        },

        async getTimeRange(file, timeColumn) {
          const res = await fetch(
            `${API_BASE}/api/range?file=${encodeURIComponent(
              file
            )}&time_column=${encodeURIComponent(timeColumn)}`
          );
          return await res.json();
        },

        async queryData(params) {
          const res = await fetch(`${API_BASE}/api/query`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(params),
          });
          return await res.json();
        },
      };

      // ===========================================
      // Utility Functions
      // ===========================================
      const formatBytes = (bytes) => {
        if (bytes === 0) return "0 Bytes";
        const k = 1024;
        const sizes = ["Bytes", "KB", "MB", "GB"];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + " " + sizes[i];
      };

      const formatNumber = (num) => {
        return new Intl.NumberFormat().format(num);
      };

      const debounce = (func, wait) => {
        let timeout;
        return (...args) => {
          clearTimeout(timeout);
          timeout = setTimeout(() => func.apply(this, args), wait);
        };
      };

      // Color palette for series
      const COLORS = [
        "#3b82f6",
        "#ef4444",
        "#10b981",
        "#f59e0b",
        "#8b5cf6",
        "#ec4899",
        "#06b6d4",
        "#84cc16",
        "#f97316",
        "#6366f1",
      ];

      // ===========================================
      // Components
      // ===========================================

      // Loading Spinner Component
      const Spinner = () => (
        <div className="flex items-center justify-center p-4">
          <div className="spinner"></div>
        </div>
      );

      // File Selector Component
      const FileSelector = ({ files, selectedFile, onSelect, loading }) => (
        <div className="bg-gray-800 rounded-lg p-4 shadow-lg">
          <h2 className="text-lg font-semibold mb-3 text-blue-400 flex items-center gap-2">
            <svg
              className="w-5 h-5"
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24"
            >
              <path
                strokeLinecap="round"
                strokeLinejoin="round"
                strokeWidth={2}
                d="M3 7v10a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-6l-2-2H5a2 2 0 00-2 2z"
              />
            </svg>
            Parquet Files
          </h2>

          {loading ? (
            <Spinner />
          ) : (
            <div className="space-y-2 max-h-60 overflow-y-auto">
              {files.length === 0 ? (
                <p className="text-gray-400 text-sm">No parquet files found</p>
              ) : (
                files.map((file) => (
                  <button
                    key={file.name}
                    onClick={() => onSelect(file)}
                    className={`w-full text-left p-3 rounded-lg transition-all ${
                      selectedFile?.name === file.name
                        ? "bg-blue-600 text-white"
                        : "bg-gray-700 hover:bg-gray-600 text-gray-200"
                    }`}
                  >
                    <div className="font-medium truncate">{file.name}</div>
                    <div className="text-xs opacity-75 mt-1">
                      {formatBytes(file.size_bytes)} •{" "}
                      {formatNumber(file.row_count)} rows
                    </div>
                  </button>
                ))
              )}
            </div>
          )}
        </div>
      );

      // Column Selector Component
      const ColumnSelector = ({
        columns,
        timeColumn,
        selectedColumns,
        onTimeColumnChange,
        onColumnToggle,
        loading,
      }) => {
        const temporalColumns = columns.filter(
          (c) => c.category === "temporal" || c.category === "numeric"
        );
        const numericColumns = columns.filter((c) => c.category === "numeric");

        return (
          <div className="bg-gray-800 rounded-lg p-4 shadow-lg">
            <h2 className="text-lg font-semibold mb-3 text-blue-400 flex items-center gap-2">
              <svg
                className="w-5 h-5"
                fill="none"
                stroke="currentColor"
                viewBox="0 0 24 24"
              >
                <path
                  strokeLinecap="round"
                  strokeLinejoin="round"
                  strokeWidth={2}
                  d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2"
                />
              </svg>
              Columns
            </h2>

            {loading ? (
              <Spinner />
            ) : columns.length === 0 ? (
              <p className="text-gray-400 text-sm">Select a file first</p>
            ) : (
              <div className="space-y-4">
                {/* Time Column Selector */}
                <div>
                  <label className="block text-sm font-medium text-gray-300 mb-2">
                    X-Axis (Time Column)
                  </label>
                  <select
                    value={timeColumn || ""}
                    onChange={(e) => onTimeColumnChange(e.target.value)}
                    className="w-full bg-gray-700 border border-gray-600 rounded-lg px-3 py-2 text-white focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                  >
                    <option value="">Select time column...</option>
                    {temporalColumns.map((col) => (
                      <option key={col.name} value={col.name}>
                        {col.name} ({col.type})
                      </option>
                    ))}
                  </select>
                </div>

                {/* Value Columns */}
                <div>
                  <label className="block text-sm font-medium text-gray-300 mb-2">
                    Y-Axis Variables ({selectedColumns.length} selected)
                  </label>
                  <div className="max-h-64 overflow-y-auto space-y-1">
                    {numericColumns.map((col, idx) => (
                      <label
                        key={col.name}
                        className={`flex items-center gap-3 p-2 rounded cursor-pointer transition-colors ${
                          selectedColumns.includes(col.name)
                            ? "bg-gray-700"
                            : "hover:bg-gray-700/50"
                        }`}
                      >
                        <input
                          type="checkbox"
                          checked={selectedColumns.includes(col.name)}
                          onChange={() => onColumnToggle(col.name)}
                          className="w-4 h-4 rounded border-gray-500 text-blue-600 focus:ring-blue-500"
                        />
                        <span
                          className="w-3 h-3 rounded-full"
                          style={{
                            backgroundColor: COLORS[idx % COLORS.length],
                          }}
                        />
                        <span className="flex-1 truncate text-sm">
                          {col.name}
                        </span>
                        <span className="text-xs text-gray-500">
                          {col.type}
                        </span>
                      </label>
                    ))}
                  </div>
                </div>
              </div>
            )}
          </div>
        );
      };

      // Query Settings Component
      const QuerySettings = ({ settings, onChange }) => (
        <div className="bg-gray-800 rounded-lg p-4 shadow-lg">
          <h2 className="text-lg font-semibold mb-3 text-blue-400 flex items-center gap-2">
            <svg
              className="w-5 h-5"
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24"
            >
              <path
                strokeLinecap="round"
                strokeLinejoin="round"
                strokeWidth={2}
                d="M12 6V4m0 2a2 2 0 100 4m0-4a2 2 0 110 4m-6 8a2 2 0 100-4m0 4a2 2 0 110-4m0 4v2m0-6V4m6 6v10m6-2a2 2 0 100-4m0 4a2 2 0 110-4m0 4v2m0-6V4"
              />
            </svg>
            Settings
          </h2>

          <div className="space-y-4">
            <div>
              <label className="block text-sm font-medium text-gray-300 mb-2">
                Max Points: {formatNumber(settings.maxPoints)}
              </label>
              <input
                type="range"
                min="500"
                max="10000"
                step="500"
                value={settings.maxPoints}
                onChange={(e) =>
                  onChange({ ...settings, maxPoints: parseInt(e.target.value) })
                }
                className="w-full"
              />
            </div>

            <div>
              <label className="block text-sm font-medium text-gray-300 mb-2">
                Downsample Method
              </label>
              <select
                value={settings.downsampleMethod}
                onChange={(e) =>
                  onChange({ ...settings, downsampleMethod: e.target.value })
                }
                className="w-full bg-gray-700 border border-gray-600 rounded-lg px-3 py-2 text-white focus:ring-2 focus:ring-blue-500"
              >
                <option value="lttb">LTTB (Best Visual)</option>
                <option value="minmax">Min/Max (Peak Preservation)</option>
                <option value="avg">Average</option>
              </select>
            </div>
          </div>
        </div>
      );

      // Stats Display Component
      const StatsDisplay = ({ stats }) => (
        <div className="bg-gray-800 rounded-lg p-4 shadow-lg">
          <h2 className="text-lg font-semibold mb-3 text-blue-400 flex items-center gap-2">
            <svg
              className="w-5 h-5"
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24"
            >
              <path
                strokeLinecap="round"
                strokeLinejoin="round"
                strokeWidth={2}
                d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z"
              />
            </svg>
            Query Stats
          </h2>

          <div className="grid grid-cols-2 gap-4 text-sm">
            <div>
              <div className="text-gray-400">Total Points</div>
              <div className="text-xl font-bold">
                {formatNumber(stats.totalPoints || 0)}
              </div>
            </div>
            <div>
              <div className="text-gray-400">Displayed</div>
              <div className="text-xl font-bold">
                {formatNumber(stats.returnedPoints || 0)}
              </div>
            </div>
            <div>
              <div className="text-gray-400">Downsampled</div>
              <div
                className={`text-lg font-bold ${
                  stats.downsampled ? "text-yellow-400" : "text-green-400"
                }`}
              >
                {stats.downsampled ? "Yes" : "No"}
              </div>
            </div>
            <div>
              <div className="text-gray-400">Query Time</div>
              <div className="text-lg font-bold">{stats.queryTime || 0}ms</div>
            </div>
          </div>
        </div>
      );

      // Main Chart Component
      const Chart = ({
        data,
        timeColumn,
        valueColumns,
        onZoom,
        loading,
        timeRange,
      }) => {
        const chartRef = useRef(null);
        const chartInstance = useRef(null);
        const isZooming = useRef(false);

        // Initialize chart
        useEffect(() => {
          if (!chartRef.current) return;

          chartInstance.current = echarts.init(chartRef.current, "dark");

          // Handle resize
          const resizeObserver = new ResizeObserver(() => {
            chartInstance.current?.resize();
          });
          resizeObserver.observe(chartRef.current);

          return () => {
            resizeObserver.disconnect();
            chartInstance.current?.dispose();
          };
        }, []);

        // Update chart data
        useEffect(() => {
          if (!chartInstance.current || !data || !timeColumn) return;

          const timeData = data[timeColumn] || [];

          const series = valueColumns.map((col, idx) => ({
            name: col,
            type: "line",
            symbol: "none",
            sampling: "lttb",
            data: (data[col] || []).map((val, i) => [timeData[i], val]),
            lineStyle: {
              width: 1.5,
            },
            emphasis: {
              lineStyle: {
                width: 2,
              },
            },
          }));

          const option = {
            backgroundColor: "transparent",
            animation: false,
            tooltip: {
              trigger: "axis",
              backgroundColor: "rgba(30, 41, 59, 0.95)",
              borderColor: "#475569",
              textStyle: {
                color: "#e2e8f0",
              },
              formatter: (params) => {
                if (!params.length) return "";
                const time = new Date(params[0].value[0] * 1000).toISOString();
                let html = `<div class="font-semibold mb-2">${time}</div>`;
                params.forEach((p) => {
                  const value = p.value[1]?.toFixed(6) ?? "N/A";
                  html += `<div class="flex justify-between gap-4">
                                    <span>${p.marker} ${p.seriesName}</span>
                                    <span class="font-mono">${value}</span>
                                </div>`;
                });
                return html;
              },
            },
            legend: {
              type: "scroll",
              top: 10,
              textStyle: {
                color: "#9ca3af",
              },
              pageTextStyle: {
                color: "#9ca3af",
              },
            },
            grid: {
              top: 60,
              left: 60,
              right: 40,
              bottom: 80,
            },
            xAxis: {
              type: "value",
              min: timeRange?.min,
              max: timeRange?.max,
              axisLabel: {
                formatter: (val) => {
                  const date = new Date(val * 1000);
                  return date.toISOString().substr(11, 8);
                },
                color: "#9ca3af",
              },
              axisLine: {
                lineStyle: { color: "#374151" },
              },
              splitLine: {
                lineStyle: { color: "#1f2937" },
              },
            },
            yAxis: {
              type: "value",
              axisLabel: {
                color: "#9ca3af",
                formatter: (val) => val.toPrecision(4),
              },
              axisLine: {
                lineStyle: { color: "#374151" },
              },
              splitLine: {
                lineStyle: { color: "#1f2937" },
              },
            },
            dataZoom: [
              {
                type: "inside",
                xAxisIndex: 0,
                filterMode: "none",
                throttle: 100,
              },
              {
                type: "slider",
                xAxisIndex: 0,
                filterMode: "none",
                bottom: 20,
                height: 30,
                borderColor: "#374151",
                backgroundColor: "#1f2937",
                fillerColor: "rgba(59, 130, 246, 0.2)",
                handleStyle: {
                  color: "#3b82f6",
                },
                textStyle: {
                  color: "#9ca3af",
                },
                brushSelect: false,
              },
            ],
            series,
            color: COLORS,
          };

          chartInstance.current.setOption(option, true);

          // Handle zoom events
          chartInstance.current.off("datazoom");
          chartInstance.current.on(
            "datazoom",
            debounce((params) => {
              if (isZooming.current) return;

              const xAxis = chartInstance.current
                .getModel()
                .getComponent("xAxis", 0);
              const extent = xAxis.axis.scale.getExtent();

              if (extent[0] !== undefined && extent[1] !== undefined) {
                onZoom?.(extent[0], extent[1]);
              }
            }, 300)
          );
        }, [data, timeColumn, valueColumns, timeRange]);

        return (
          <div className="relative bg-gray-800 rounded-lg shadow-lg overflow-hidden">
            {loading && (
              <div className="absolute inset-0 bg-gray-900/70 flex items-center justify-center z-10">
                <div className="flex items-center gap-3">
                  <div className="spinner"></div>
                  <span>Loading data...</span>
                </div>
              </div>
            )}
            <div ref={chartRef} className="w-full h-[500px]"></div>
          </div>
        );
      };

      // ===========================================
      // Main App Component
      // ===========================================
      const App = () => {
        // State
        const [files, setFiles] = useState([]);
        const [selectedFile, setSelectedFile] = useState(null);
        const [columns, setColumns] = useState([]);
        const [timeColumn, setTimeColumn] = useState(null);
        const [selectedColumns, setSelectedColumns] = useState([]);
        const [timeRange, setTimeRange] = useState(null);
        const [currentRange, setCurrentRange] = useState(null);
        const [data, setData] = useState({});
        const [stats, setStats] = useState({});
        const [settings, setSettings] = useState({
          maxPoints: 2000,
          downsampleMethod: "lttb",
        });

        // Loading states
        const [loadingFiles, setLoadingFiles] = useState(true);
        const [loadingColumns, setLoadingColumns] = useState(false);
        const [loadingData, setLoadingData] = useState(false);

        // Load files on mount
        useEffect(() => {
          const loadFiles = async () => {
            setLoadingFiles(true);
            try {
              const files = await api.getFiles();
              setFiles(files);
            } catch (err) {
              console.error("Error loading files:", err);
            }
            setLoadingFiles(false);
          };
          loadFiles();
        }, []);

        // Load columns when file changes
        useEffect(() => {
          if (!selectedFile) {
            setColumns([]);
            setTimeColumn(null);
            setSelectedColumns([]);
            return;
          }

          const loadColumns = async () => {
            setLoadingColumns(true);
            try {
              const cols = await api.getColumns(selectedFile.name);
              setColumns(cols);

              // Auto-select first temporal column as time
              const temporalCol = cols.find((c) => c.category === "temporal");
              if (temporalCol) {
                setTimeColumn(temporalCol.name);
              }
            } catch (err) {
              console.error("Error loading columns:", err);
            }
            setLoadingColumns(false);
          };
          loadColumns();
        }, [selectedFile]);

        // Load time range when time column changes
        useEffect(() => {
          if (!selectedFile || !timeColumn) {
            setTimeRange(null);
            return;
          }

          const loadRange = async () => {
            try {
              const range = await api.getTimeRange(
                selectedFile.name,
                timeColumn
              );
              setTimeRange({
                min: range.min_epoch,
                max: range.max_epoch,
              });
              setCurrentRange({
                start: range.min_epoch,
                end: range.max_epoch,
              });
            } catch (err) {
              console.error("Error loading time range:", err);
            }
          };
          loadRange();
        }, [selectedFile, timeColumn]);

        // Query data function
        const queryData = useCallback(
          async (startTime, endTime) => {
            if (!selectedFile || !timeColumn || selectedColumns.length === 0) {
              return;
            }

            setLoadingData(true);
            const queryStart = performance.now();

            try {
              const result = await api.queryData({
                file: selectedFile.name,
                time_column: timeColumn,
                value_columns: selectedColumns,
                start_time: startTime,
                end_time: endTime,
                max_points: settings.maxPoints,
                downsample_method: settings.downsampleMethod,
              });

              const queryTime = Math.round(performance.now() - queryStart);

              setData(result.data);
              setStats({
                totalPoints: result.total_points,
                returnedPoints: result.returned_points,
                downsampled: result.downsampled,
                queryTime,
              });
            } catch (err) {
              console.error("Error querying data:", err);
            }

            setLoadingData(false);
          },
          [selectedFile, timeColumn, selectedColumns, settings]
        );

        // Initial data load and when selections change
        useEffect(() => {
          if (currentRange) {
            queryData(currentRange.start, currentRange.end);
          }
        }, [selectedColumns, currentRange?.start, currentRange?.end, settings]);

        // Handle zoom
        const handleZoom = useCallback((start, end) => {
          setCurrentRange({ start, end });
        }, []);

        // Toggle column selection
        const handleColumnToggle = (columnName) => {
          setSelectedColumns((prev) => {
            if (prev.includes(columnName)) {
              return prev.filter((c) => c !== columnName);
            }
            return [...prev, columnName];
          });
        };

        // Reset zoom
        const handleResetZoom = () => {
          if (timeRange) {
            setCurrentRange({
              start: timeRange.min,
              end: timeRange.max,
            });
          }
        };

        return (
          <div className="min-h-screen flex flex-col">
            {/* Header */}
            <header className="bg-gray-800 shadow-lg border-b border-gray-700">
              <div className="max-w-screen-2xl mx-auto px-4 py-4">
                <div className="flex items-center justify-between">
                  <div className="flex items-center gap-3">
                    <svg
                      className="w-8 h-8 text-blue-500"
                      fill="none"
                      stroke="currentColor"
                      viewBox="0 0 24 24"
                    >
                      <path
                        strokeLinecap="round"
                        strokeLinejoin="round"
                        strokeWidth={2}
                        d="M7 12l3-3 3 3 4-4M8 21l4-4 4 4M3 4h18M4 4h16v12a1 1 0 01-1 1H5a1 1 0 01-1-1V4z"
                      />
                    </svg>
                    <div>
                      <h1 className="text-xl font-bold text-white">
                        Parquet Viewer
                      </h1>
                      <p className="text-xs text-gray-400">Powered by DuckDB</p>
                    </div>
                  </div>

                  <div className="flex items-center gap-4">
                    <button
                      onClick={handleResetZoom}
                      disabled={!timeRange}
                      className="px-4 py-2 bg-gray-700 hover:bg-gray-600 rounded-lg text-sm font-medium transition-colors disabled:opacity-50"
                    >
                      Reset Zoom
                    </button>
                  </div>
                </div>
              </div>
            </header>

            {/* Main Content */}
            <main className="flex-1 max-w-screen-2xl mx-auto w-full px-4 py-6">
              <div className="grid grid-cols-12 gap-6">
                {/* Sidebar */}
                <aside className="col-span-3 space-y-6">
                  <FileSelector
                    files={files}
                    selectedFile={selectedFile}
                    onSelect={setSelectedFile}
                    loading={loadingFiles}
                  />

                  <ColumnSelector
                    columns={columns}
                    timeColumn={timeColumn}
                    selectedColumns={selectedColumns}
                    onTimeColumnChange={setTimeColumn}
                    onColumnToggle={handleColumnToggle}
                    loading={loadingColumns}
                  />

                  <QuerySettings settings={settings} onChange={setSettings} />

                  <StatsDisplay stats={stats} />
                </aside>

                {/* Chart Area */}
                <div className="col-span-9">
                  {selectedFile && timeColumn && selectedColumns.length > 0 ? (
                    <Chart
                      data={data}
                      timeColumn={timeColumn}
                      valueColumns={selectedColumns}
                      onZoom={handleZoom}
                      loading={loadingData}
                      timeRange={currentRange}
                    />
                  ) : (
                    <div className="bg-gray-800 rounded-lg shadow-lg h-[500px] flex items-center justify-center">
                      <div className="text-center text-gray-400">
                        <svg
                          className="w-16 h-16 mx-auto mb-4 opacity-50"
                          fill="none"
                          stroke="currentColor"
                          viewBox="0 0 24 24"
                        >
                          <path
                            strokeLinecap="round"
                            strokeLinejoin="round"
                            strokeWidth={1.5}
                            d="M11 3.055A9.001 9.001 0 1020.945 13H11V3.055z"
                          />
                          <path
                            strokeLinecap="round"
                            strokeLinejoin="round"
                            strokeWidth={1.5}
                            d="M20.488 9H15V3.512A9.025 9.025 0 0120.488 9z"
                          />
                        </svg>
                        <p className="text-lg font-medium mb-2">
                          No Data to Display
                        </p>
                        <p className="text-sm">
                          {!selectedFile
                            ? "Select a parquet file to begin"
                            : !timeColumn
                            ? "Select a time column for the X-axis"
                            : "Select one or more variables to plot"}
                        </p>
                      </div>
                    </div>
                  )}

                  {/* Range Info */}
                  {currentRange && (
                    <div className="mt-4 bg-gray-800 rounded-lg p-4 shadow-lg">
                      <div className="flex items-center justify-between text-sm">
                        <div>
                          <span className="text-gray-400">Current Range: </span>
                          <span className="font-mono">
                            {new Date(currentRange.start * 1000).toISOString()}
                          </span>
                          <span className="text-gray-500 mx-2">→</span>
                          <span className="font-mono">
                            {new Date(currentRange.end * 1000).toISOString()}
                          </span>
                        </div>
                        <div className="text-gray-400">
                          Duration:{" "}
                          {(
                            (currentRange.end - currentRange.start) /
                            60
                          ).toFixed(2)}{" "}
                          min
                        </div>
                      </div>
                    </div>
                  )}
                </div>
              </div>
            </main>

            {/* Footer */}
            <footer className="bg-gray-800 border-t border-gray-700 py-3">
              <div className="max-w-screen-2xl mx-auto px-4">
                <div className="flex items-center justify-between text-sm text-gray-400">
                  <span>Parquet Viewer v1.0.0</span>
                  <span>Extensible data visualization for large datasets</span>
                </div>
              </div>
            </footer>
          </div>
        );
      };

      // Mount the app
      const root = ReactDOM.createRoot(document.getElementById("root"));
      root.render(<App />);
    </script>
  </body>
</html>
